// 1) Типи данних в JS
// Є 8 типів данних в Js: String, Boolean, Number, null, undefined, object, Symbol, BigInt
// 2) Що таке ES
// Стандарт яким курується JS
// 3) Назвати всі методи масивів, які ви знаєте
// push, shift, unshift, delete, pop, concat, replace, splice, join, split, trim, indexOf, lastIndexOf, charAt,
// sort, filter, map, reduce, includes, find, reverse, some, every, flat, forEach
// 4) JSON це
// Java Script Object Notation
// 5) Напишіть каунтер на замикання. Ручками
//     function myFunc(){
//         let a = 0;
//     function plus(){
//         a++;
//         console.log(a);
//     }
//     return plus;
//     }
//     let b = myFunc();
//     b();
// 6) Переберіть масив за допомогою рекурсії. БЕЗ Циклів
//        let arr = [1, 5, 'Hi', false, 8, 'Nice'];
//        let i = 0;
//         function recursion(){
//             console.log(arr[i]);
//             i++;
//             if(i < arr.length) {
//                 recursion(i);
//             } else {
//                 return;
//             }
//         }
//         recursion(arr);
// 7) Що таке arguments ? Чи можу я його перебрати циклом forEach ?
//      Якщо я маю дуже багато аргументів, то їх можна прийняти за допомогою змінної arguments(яка вже є
//      автоматичностворена), но він є тільки у function declaration і вертає масив аргументів, які я передав у функцію
//      arguments - це псевдомасив (це обєкт, який поводить себе як масив, і засоби масиву для нього не викорис.!!), но
//      можна перебрати простими циклами. Так можна перебрати за допомогою forEach
//         let arr = ['Hi', 'Buy', ['Nice', 'Gid'], 'Fine'];
//         function arrBack(arguments){
//             arguments.forEach(value => console.log(value));
//         }
//         arrBack(arr);
// 8) Що таке Hosting (підняття)
//      hoisting - річ яка дозволяє викликати функції до їх оголошення, наприклад declaration можу викликати швидше,
//      ніж оголосив функцію, а expression так Не Можна (тільки після)!!!!
// 9) Стрілочні функції. Різниця з простими функціями
//     Expression function (як стрілочні функції (arrow function)):
//     let arrow = (a, b) => {console.log(a);} arrow('Hi');, Немає arguments!!!
//     Якщо вона написана у Lexical Environment - то її за межами не можна викликати, а Declaration function можна!
//     У arrow function замість return можна зробити такий запис: let sumator = (a, b) => a + b;
//     це то саме, що написати let sumator = (a, b) =>{return a + b;}, і Якщо стрілочна функція примає один параметр,
//     то дужки можна не писати, тобто let sumator = a => a + 999;, но можна і ставити дужки let sumator = (a) => a + 999;
//     Різниця від простих : інший запис, немають hoisting, не можна викликати за межами Lexical Environment, немають
//     arguments, і ще вроді є різниця у this
// 10) Що таке Promise. Які він має стани
//      Promise(новий спосіб обробляти асинхронність) - проміси, проміс - це Обєкт!, який має 3 стани: 41)
//      Pending(очікування, очікує поки щось зробиться);
//      2)Reject(фінальний стан, коли проміс виконався не успішно);
//      3)Resolve(фінальний стан, коли проміс виконався успішно);
//      І після Reject і Resolve вже вернутися не можна, і нічого не зробиш, бо це Фінальні стани.
// 11) Що таке Currying ?
//      Call Apply Bind(carrying) - це привязка до контексту this, наприклад - let user ={name: 'Hi', age: 18};
//      let dimas ={name: 'Dimas', wife: false, age: 25}; function changeAge(newAge){this.age = 30;} changeAge.apply(user),
//      changeAge.apply(або changeAge.call, вони майже не відрізняються)changeAge.call(dimas),
//      call і apply викликають функцію одноразово, а ще є bind changeAge.bind(user), і воно створює нову функцію (копію старої)
//      let arr = changeAge.bind(user); arr(); Оце і різниця між apply, call і bind - що bind створю нову функцію
//      з жосткою привязкою, а apply і call викликаються одноразово, НО якщо записати так
//      let user ={name: 'Hi', age: 18}; let dimas ={name: 'Dimas', wife: false, age: 25};
//      function changeAge(newAge){this.age = newAge;} changeAge.apply(user, [56]); changeAge.call(user, 18),
//      тобто щоб передати це newAge в apply передаємо через масив, а в call просто через кому,
//      в тому і різниця між call і apply, а bind так само передається як call (changeAge.bind(user, 18))
// 12) На що ссилається this ? А в <<стрілках>> ?
//      Ключове слово this посилається на особливу властивість контексту виконання функції.
//      У стрілкових функціях this зберігає значення this оточуючого лексичного контексту.

// 13) Все що ви знаєте про Object.assign
//     Object.assign() - через нього також можна робити копії, так як і з JSON,
//     Object.assign() - об'єднює об'єкти, наприклад з двох об'єктів зробити один Великий об'єкт
// let obj1 = {name: 'Hi'}; let obj2 = {name: 'Log', age: 18}; let assign = Object.assign(obj1, obj2); І вийде name: log, age: 18,
//     бо ім'я бере останнє, якщо ключі однакові - то візьме останнє значення (переприсвоє),
//     НО ще Першому елементу (obj1) йому зміняться, добавляться властивості!
//     Для того щоб не поміняло 1 елемент, треба напочатку задати пустий об'єкт Object.assign({}, obj1, obj2); І
//     тоді все буде добре, (target має бути {}, щоб не поміняло перший, бо target - це те, що будемо міняти).
//     Но Object.assign робить тільки однорівневу копію, наприклад я зробив копію obj1 і в assign хочу поміняти ім'я,
//     то буде assign.name = 'Hll'; І все буде добре, но якщо в obj1 є більше рівнів, наприклад об'єкт в об'єкті,
//     я щось зміню, наприклад assign.name.color = 'Hll'; то color зміниться і там і там!!!
//     Тому копія Object.assign треба робити однорівневу
// 14) Прототип. Плюси і мінуси
//     Ну плюси в тому, що вони займають менше памяті(вони були ств для економії памяті), а мінуси в тому, що якщо
//     створити якийсь метод - то він буде застосовуватися до усіх(спільний для для всіх),
// 15) Все що знаєте про ООП. Написати приклад з наслідуванням
// ООП(Об'єктно Орієнтовне Програмування(це ніби усе навколо нас є об'єкт, і ми можемо описати будь що як об'єкт)): Є 4 основних принципа ООП: Абстракція, Інкапсуляція, Наслідування, Поліморфізм
// Абстракція - в мене може бути (не обов'язково що буде, але може бути) якісь такий елемент, екземпляри якого не можна зробити, але від нього можна наслідуватись, наприклад коли роблю машинки, то я її не роблю з 0, а є якась платформа рама і 4 колеса, платформа на основі якої я можу будувати цю машину, є якась платформа, на одному заводі генерю платформи і цю платформу передаю на інший завод, щоб він робив на основі рами і коліс вже машинки. Це і наз. абстракцією. В мене є якась заготовка, на основі якої я можу робити вже готові об'єкти, але екземпляр заготовки я неможу створити, неможна взяти раму з колесами і кататися, на основі ній будуються машинки, або якщо є фігура но не понятна яка і є методи порахувати площу, периметр, но непонятна, яка фігура, і ми не можемо порахувати щось, бо незнаємо що це є, але на основі фігури ми можемо зробити трикутник і порахувати або квадрат і т.д., але фігура це просто абстрактна штука, ми знаємо що фігура, а яка - незнаємо, тому на основі фігури треба зробити нормальну
// Інкапсуляція - основний принцип це скрити якісь властивості від нашого користувача, тобто як була у нас команда build, то користувач знає що треба її написати і вона виконається, но він незнає що відбувається під капотом (як іменно вона викон. і т.д.), (це типу ще як пхаєш ключ в машину, щоб завести, повертаєш і вона заводиться, но я незнаю, що відбувається під капотом, коли я повертаю ключ, то щось відбувається ще, но я того не бачу і незнаю)
// Наслідування - наприклад я батьківський клас і є дочка (нащадок мій), якщо вона є нащадком - то вона взяла від мене деякі властивості, тобто це і є наслідування, тобто властивість, що дочірній клас приймає властивості від батьківського класу, з можливостю додавання своїх (наприклад можна ще щось навчити дочку, того чого я не знав і не вмів), но вона неможе передати ці можливості мені (тобто я можу її щось навчити, але вона мене - ні!)
// Поліморфізм - це властивість елементів поводитися по різному, але один метод (одна функція)... це можливість викорис 1 метод але може поводитися по різному взалежності від заданих йому параметрів (наприклад це як одне слово, яке має різне значення взалежності в якому контексті скажеш, наголос (омоніми))
// Наслідування на класах(Extends):
//  class Human{constructor(width, height, name = 'No Name'){this.width = width; this.height = height; this.name =
//  name;}
//  greeting(){console.log(this.name + ' say')}};
//  class Developer extends Human{constructor(width, height, name, skill){ super(width, height, name); this.skill =
//  skill;}};
//  let student = new Human(60, 70); let dev = new Developer(120, 80, 'Anton'); student.greeting();
//  console.log(student); dev.greeting(); console.log(dev);
//  Якщо super не буде, то прийдеться знову прописувати this.name = name і т.д., а з super, то воно наслідує з
//  батьківського класу,
//     НО у батьківському super писати не можна!!! тільки тим, які наслідуються, а не від кого.
//     І greeting метод можна переприсвоїти (змінити) у класа нащадка (dev), а батьківський залишиться тим, яким був
// Prototype - наслідування на прототипах, function Animal(name, color){this.name = name; this.color = color;} Animal.prototype.run = function(){console.log('run');} Тут функції конструктора пишуть у Прототипі, тобто могли написати run там де this.name..., но функції пишуться окремо у прототипі!!
//     Є 3 способи наслідування на прототипах:
//     Поганий - function Animal(name, color){this.name = name; this.color = color;} Animal.prototype.run = function(){console.log('run');} function Hamster(name, color, house){this.name = name; this.color = color; this.house = house;}; Hamster.prototype = Animal.prototype;(самий поганий спосіб, бо вони мутують, якщо я зміню функцію у Hamster, то зміниться і у Animal) let xx= new Animal('xx', 'white');
// Нормальний - function Animal(name, color){this.name = name; this.color = color;} Animal.prototype.run = function(){console.log('run');} function Hamster(name, color, house){this.name = name; this.color = color; this.house = house;}; Hamster.prototype.__proto__ = Animal.prototype;(так працює все добре(не мутує), но не найкращий спосіб!) let xx= new Animal('xx', 'white');
// Найкращий (якого і юзаємо) - function Animal(name, color){this.name = name; this.color = color;} Animal.prototype.run = function(){console.log('run');} function Hamster(name, color, house){this.name = name; this.color = color; this.house = house;}; Hamster.prototype = Object.create(Animal.prototype);(Найкращий спосіб!, і також нічого не мутує) let xx= new Animal('xx', 'white'); НО Object.create - однорівнева копія!